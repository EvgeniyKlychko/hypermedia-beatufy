export declare const VertexShader = "\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n";
export declare const PixelShader = "\n// #define MSIZE 15\n// #define SKIN_DETECTION\nuniform vec3 iResolution;\nuniform float iTime;\nuniform sampler2D iChannel0;\nuniform float Brightness;\nuniform float SIGMA;\nuniform float BSIGMA;\nvarying vec2 vUv;\nvec3 iMouse = vec3(0,0,0);\n\nconst bool GAMMA_CORRECTION = false;\nfloat kernel[MSIZE];\n\nfloat normpdf(in float x, in float sigma) {\n\treturn 0.39894 * exp(-0.5 * x * x/ (sigma * sigma)) / sigma;\n}\nfloat normpdf3(in vec3 v, in float sigma) {\n\treturn 0.39894 * exp(-0.5 * dot(v,v) / (sigma * sigma)) / sigma;\n}\nfloat normalizeColorChannel(in float value, in float min, in float max) {\n  return (value - min)/(max-min);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 c = texture(iChannel0, (fragCoord.xy / iResolution.xy)).rgb;\n  const int kSize = (MSIZE - 1) / 2;\n  vec3 final_colour = vec3(0.0);\n  float Z = 0.0;\n\n  // #ifdef USE_CONSTANT_KERNEL\n  //   // unfortunately, WebGL 1.0 does not support constant arrays...\n  //   kernel[0] = kernel[14] = 0.031225216;\n  //   kernel[1] = kernel[13] = 0.033322271;\n  //   kernel[2] = kernel[12] = 0.035206333;\n  //   kernel[3] = kernel[11] = 0.036826804;\n  //   kernel[4] = kernel[10] = 0.038138565;\n  //   kernel[5] = kernel[9]  = 0.039104044;\n  //   kernel[6] = kernel[8]  = 0.039695028;\n  //   kernel[7] = 0.039894000;\n  //   float bZ = 0.2506642602897679;\n  // #else\n    //create the 1-D kernel\n    for (int j = 0; j <= kSize; ++j) {\n      kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), SIGMA);\n    }\n    float bZ = 1.0 / normpdf(0.0, BSIGMA);\n  // #endif\n\n  vec3 cc;\n  float factor;\n  //read out the texels\n  for (int i=-kSize; i <= kSize; ++i) {\n    for (int j=-kSize; j <= kSize; ++j) {\n      cc = texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n      factor = normpdf3(cc-c, BSIGMA) * bZ * kernel[kSize+j] * kernel[kSize+i];\n      Z += factor;\n      if (GAMMA_CORRECTION) {\n        final_colour += factor * pow(cc, vec3(2.2));\n      } else {\n        final_colour += factor * cc;\n      }\n    }\n  }\n\n  if (GAMMA_CORRECTION) {\n    fragColor = vec4(pow(final_colour / Z, vec3(1.0/2.2)), 1.0);\n  } else {\n    fragColor = vec4(final_colour / Z, 1.0);\n  }\n\n  bool isSkin = true;\n  #ifdef SKIN_DETECTION\n    isSkin = false;\n    vec4 rgb = fragColor * 255.0;\n    vec4 ycbcr = rgb;\n    ycbcr.x = 16.0 + rgb.x*0.257 + rgb.y*0.504 + rgb.z*0.098;\n    ycbcr.y = 128.0 - rgb.x*0.148 - rgb.y*0.291 + rgb.z*0.439;\n    ycbcr.z = 128.0 + rgb.x*0.439 - rgb.y*0.368 - rgb.z*0.071;\n    if (ycbcr.y > 100.0 && ycbcr.y < 118.0 && ycbcr.z > 121.0 && ycbcr.z < 161.0) {\n      isSkin = true;\n    }\n  #endif\n\n  if (iMouse.z > 0.0 || !isSkin) {\n    fragColor = vec4(texture(iChannel0, fragCoord.xy / iResolution.xy).xyz, 1.0);\n  }\n\n  fragColor = vec4(fragColor.xyz * Brightness, 1.0);\n}\n\nvoid main() {\n  mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n";
